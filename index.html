<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EYEZ Generator</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: #000;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
    }
    canvas {
      display: block;
      max-width: 100vw;
      max-height: 100vh;
      object-fit: contain;
      cursor: pointer;
    }

    /* Overlay menu (same as Mandala) */
    #overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #panel {
      background: rgba(10,10,16,0.98);
      border-radius: 16px;
      padding: 1.5rem 1.8rem;
      width: min(90vw, 420px);
      box-shadow: 0 18px 60px rgba(0,0,0,0.9);
      border: 1px solid rgba(255,255,255,0.1);
    }
    #panel h2 {
      font-size: 1.1rem;
      margin-bottom: 0.75rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #e3e7ff;
    }
    #panel p {
      font-size: 0.8rem;
      color: #a5aac4;
      margin-bottom: 0.9rem;
    }
    .tag {
      font-size: 0.7rem;
      opacity: 0.7;
      margin-bottom: 0.3rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 0.45rem 0.85rem;
      font-size: 0.8rem;
      background: #181926;
      color: #e9ecff;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s, box-shadow 0.15s;
      box-shadow: 0 0 0 rgba(0,0,0,0);
    }
    button:hover {
      background: #25273a;
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
      transform: translateY(-1px);
    }
    button.primary {
      background: linear-gradient(135deg,#7bfff3,#ff6ad5);
      color: #05060a;
      font-weight: 600;
    }
    button.primary:hover {
      background: linear-gradient(135deg,#9bfff7,#ff8af3);
    }
    button.outline {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.18);
    }
  </style>
</head>
<body>

<canvas id="canvas"></canvas>

<!-- Options overlay (identical layout/function to Mandala) -->
<div id="overlay">
  <div id="panel">
    <div class="tag">Options</div>
    <h2>Render &amp; Download</h2>
    <p>Double-click the art to reopen this panel. Choose a resolution to redraw, or download the current frame.</p>
    <div>
      <div class="tag">Resolution</div>
      <div class="row" id="resRow"></div>
    </div>
    <div class="row">
      <button class="primary" id="downloadBtn">Download PNG</button>
      <button class="outline" id="closeBtn">Close</button>
    </div>
  </div>
</div>

<script>
(() => {
  // --- random helpers (kept) ---
  function rD(min,max) {
    return Math.random() * (max - min) + min;
  }

  // --- resolution handling (exactly like Mandala) ---
  const RESOLUTIONS = [1024, 2048, 4096, 8192, 16384];
  let currentRes = 4096;

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  let size = currentRes;  // square backing store
  let cx = size / 2;
  let cy = size / 2;

  function setupCanvas(res) {
    size = res;
    canvas.width = size;
    canvas.height = size;
    cx = size / 2;
    cy = size / 2;
    canvas.style.width = '100vw';
    canvas.style.height = '100vh';
  }

  // ===== original eye constants (drawing unchanged) =====
  const BG="#555", SCLERA_STROKE="#fff", PUPIL_FILL="#000", HIGHLIGHT="#fff", EDGE_COLOR="#000";

  // look direction + pupil / sclera randomness will be re-randomized per redraw
  let LOOK_X = 0, LOOK_Y = 0;

  const THIN=0.18;                 // ellipse height factor
  const ASPECT=0.65;               // ellipse width factor (rx = ry*ASPECT)
  const SEP=2.175;                 // eye center separation (in rx units)
  const R0_RATIO=0.40, PR_RATIO=0.42;
  const EYE_SCALE   = 2.0;         // 2Ã— bigger eyes
  const MARGIN_FRAC = 0.04;

  document.body.style.background = BG;

  // ==== seeded random & stops (kept) ====
  let seed=(Date.now()^0x9E3779B9)>>>0;
  const reseed=()=>{seed=(seed+0x9E3779B9)>>>0;};
  const rand=()=>{
    seed|=0;
    seed=seed+0x6D2B79F5|0;
    let t=Math.imul(seed^seed>>>15,1|seed);
    t^=t+Math.imul(t^t>>>7,61|t);
    return ((t^t>>>14)>>>0)/4294967296;
  };
  const randColor=()=>`hsl(${Math.floor(rand()*360)} 80% 60%)`;

  // Split point where inner bands (round) switch to oval rim
  const RIM_START = 1;                   // 0..1

  // Pupil ring (thin annulus) & core (colors randomized per redraw)
  let RING_RIGHT, RING_LEFT;

  const RING_OUTER=1.18, RING_INNER=0.82;  // ring radii as multiples of pupil radius
  const CORE_RATIO=0.9;                   // black center radius vs pupil radius

  function highlightPosition(cx, cy, px, py, rx, ry, pr) {
    const vx = (px - cx) / rx, vy = (py - cy) / ry;
    const m  = Math.min(1, Math.hypot(vx, vy));

    let ux = px - cx, uy = py - cy;
    let len = Math.hypot(ux, uy);

    if (len === 0) return [px - pr * 0.22, py - pr * 0.22];

    ux /= len; uy /= len;

    const base = pr * (0.20 + 0.25 * m);
    const jitter = pr * 0.05 * (0.5 - rand());
    const hx = px + ux * (base + jitter);
    const hy = py + uy * (base + jitter);

    return [hx, hy];
  }

  // Soft highlight controls
  const HL_RADIUS=0.375;    // as fractions of pupil radius

  // Precise control of the very outer oval rim
  const OUTER_EDGE_GRAY="#4E4E4E";
  const RIM_WIDTH_FRAC   = .5;
  const RIM_FADE_FRACTION= .25;
  const RIM_INNER_COLOR  = "#ffffff";
  const RIM_OUTER_COLOR  = OUTER_EDGE_GRAY;

  const BORDER_FEATHER = 1;

  // Sclera gradient stops
  const makeStops=()=>{
    const stops=[[0,randColor()]];
    const n=2+Math.floor(rand()*2);
    for(let i=0;i<n;i++){
      let off=.05+rand()*.05;
      stops.push([off,'#ffffff']);
    }
    stops.sort((a,b)=>a[0]-b[0]);
    for(let i=1;i<stops.length;i++){
      if(Math.abs(stops[i][0]-stops[i-1][0])<0.01)
        stops[i][0]=Math.min(0.99,stops[i-1][0]+0.01);
    }
    stops.push([1,EDGE_COLOR]);
    return stops;
  };
  let GRADIENT_STOPS = makeStops();

  // === stop shaping helpers (kept) ===
  let SCLERA_STOP_SPREADS = [];
  let SCLERA_GLOBAL_SPREAD = 1;

  function shapeStopsWithSpreads(stops, spreads, global=1){
    const shaped = stops.map(([p,c],i)=>{
      const e = (spreads[i] ?? 1) * (global ?? 1);
      const pp = Math.max(0, Math.min(1, Math.pow(p, e)));
      return [pp, c];
    }).sort((a,b)=>a[0]-b[0]);

    if (shaped[0][0] > 0) shaped.unshift([0, shaped[0][1]]);
    if (shaped[shaped.length-1][0] < 1) shaped.push([1, shaped[shaped.length-1][1]]);
    return shaped;
  }
  function colorAt(stops, t){
    let c = stops[0][1];
    for (let i=0;i<stops.length;i++){
      if (stops[i][0] <= t) c = stops[i][1];
      else break;
    }
    return c;
  }
  function splitStops(stops, rimStart){
    const inner=[], outer=[];
    const rimColor = colorAt(stops, rimStart);
    for (const [off,col] of stops){
      if (off < rimStart) inner.push([off/rimStart, col]);
      else                outer.push([(off-rimStart)/(1-rimStart), col]);
    }
    if (!inner.length || inner[inner.length-1][0] < 1) inner.push([1, rimColor]);
    if (!outer.length || outer[0][0] > 0)              outer.unshift([0, rimColor]);
    return { inner, outer };
  }

  // === Per-redraw random bundle (look, colors, stops) ===
  let st1, st1s, st2, st2s, st3, st3s;

  function randomizeParams() {
    LOOK_X = rD(-.55,.55);
    LOOK_Y = rD(-.5,.5);

    reseed();
    GRADIENT_STOPS = makeStops();

    st1  = randColor();
    st1s = rD(0,.2);
    st2  = randColor();
    st2s = rD(.2,.5);
    st3  = randColor();
    st3s = rand();

    RING_RIGHT = randColor();
    RING_LEFT  = (() => {
      const m = RING_RIGHT.match(/^hsl\(\s*([0-9.]+)\s+([0-9.]+)%\s+([0-9.]+)%\s*\)$/i);
      if (m) {
        const h = +m[1], s = +m[2], l = +m[3];
        const darkL = Math.max(0, Math.min(100, l * 0.2));
        return `hsl(${h} ${s}% ${darkL}%)`;
      }
      return RING_RIGHT;
    })();
  }

  // === main eye draw (your art, just made resolution-aware) ===
  function draw() {
    const W = size;
    const H = size;
    const U = size;

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);

    let ry = U * THIN * EYE_SCALE;
    let rx = ry * ASPECT;

    const margin = U * MARGIN_FRAC;
    const neededW = (2 + SEP) * rx;
    const neededH = 2 * ry;
    let fit = Math.min(
      (W - 2*margin) / neededW,
      (H - 2*margin) / neededH
    );
    if (fit < 1){ rx *= fit; ry *= fit; }

    const cy = H * 0.5;
    const sep = rx * SEP;
    const cx1 = W * 0.5 - sep * 0.5;
    const cx2 = W * 0.5 + sep * 0.5;

    const outline = Math.max(.5, U * 0.018);
    ctx.lineWidth = outline;
    ctx.lineJoin = ctx.lineCap = "round";

    const shaped = shapeStopsWithSpreads(GRADIENT_STOPS, SCLERA_STOP_SPREADS, SCLERA_GLOBAL_SPREAD);
    const { inner: innerStops } = splitStops(shaped, RIM_START); // innerStops kept (matches original flow)

    const eye = (cx, cy) => {
      ctx.save();
      ctx.beginPath(); ctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2);
      ctx.clip();

      const pr = Math.min(rx,ry) * PR_RATIO;
      const px = cx + LOOK_X * rx * 0.66;
      const py = cy + LOOK_Y * ry * 0.81;
      const sPx = (px - cx);
      const sPy = (py - cy) * (rx / ry);

      // inner sclera
      const gInner = ctx.createRadialGradient(px,py, pr*R0_RATIO, px,py, rx);
      gInner.addColorStop(st1s, st1);
      gInner.addColorStop(st2s, st2);
      gInner.addColorStop(.65, '#ffffff');
      ctx.fillStyle = gInner;
      ctx.globalAlpha = 1;
      ctx.fillRect(cx-rx, cy-ry, rx*2, ry*2);

      // outer rim
      ctx.save();
      ctx.translate(cx,cy);
      ctx.scale(1, ry/rx);
      const rimOuter = rx;
      const rimInner = rx * (1 - RIM_WIDTH_FRAC);
      ctx.beginPath();
      ctx.arc(0,0,rimOuter,0,Math.PI*2);
      ctx.arc(0,0,rimInner,0,Math.PI*2,true);
      ctx.clip('evenodd');

      const fadeInner = rimOuter - (rimOuter - rimInner) * RIM_FADE_FRACTION;
      const gRim = ctx.createRadialGradient(
        sPx, sPy, fadeInner,
        0,   0,   rimOuter
      );
      gRim.addColorStop(st1s, st1);
      gRim.addColorStop(st2s, st2);
      if (typeof st3 !== "undefined") gRim.addColorStop(st3s, st3);
      ctx.globalAlpha = 1;
      ctx.fillStyle = gRim;
      ctx.restore();

      // outer feather
      ctx.save();
      ctx.beginPath(); ctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2);
      ctx.clip();
      ctx.translate(cx,cy);
      ctx.scale(1, ry/rx);
      const edgeStart = rx * (1 - BORDER_FEATHER);
      const gEdge  = ctx.createRadialGradient( sPx, sPy, edgeStart, 0, 0, rx );
      gEdge.addColorStop(st1s, st1);
      gEdge.addColorStop(st2s, st2);
      gEdge.addColorStop(st3s, st3);
      ctx.fillStyle = gEdge;

      ctx.globalCompositeOperation = 'source-over';
      const gEdge1 = ctx.createRadialGradient( sPx, sPy, edgeStart, 0, 0, rx );
      gEdge1.addColorStop(.85, 'transparent');
      gEdge1.addColorStop(1, OUTER_EDGE_GRAY);
      ctx.fillStyle = gEdge1;
      ctx.fillRect(-rx,-rx,rx*2,rx*2);
      ctx.restore();

      // pupil ring
      const RING_GRAD_ANGLE = Math.PI/4;
      const rOuter = pr * RING_OUTER, rInner = pr * RING_INNER;
      const dx = Math.cos(RING_GRAD_ANGLE)*rOuter, dy = Math.sin(RING_GRAD_ANGLE)*rOuter;
      const lg = ctx.createLinearGradient(px-dx, py-dy, px+dx, py+dy);
      lg.addColorStop(.2, RING_LEFT);
      lg.addColorStop(1, RING_RIGHT);
      ctx.beginPath();
      ctx.arc(px,py,rOuter,0,Math.PI*2);
      ctx.arc(px,py,rInner,0,Math.PI*2,true);
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = lg;
      ctx.fill("evenodd");

      // core
      ctx.beginPath();
      ctx.arc(px, py, pr*CORE_RATIO, 0, Math.PI*2.2);
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = PUPIL_FILL;
      ctx.fill();

      // highlight
      const [hx, hy] = highlightPosition(cx, cy, px, py, rx, ry, pr);
      const vxHL = (px - cx) / rx, vyHL = (py - cy) / ry;
      const mHL  = Math.min(1, Math.hypot(vxHL, vyHL));
      const hlR  = pr * (HL_RADIUS * (0.9 + 0.2 * (1 - mHL)));

      const gHL = ctx.createRadialGradient(hx, hy, 0, hx, hy, hlR);
      gHL.addColorStop(0, "rgba(255,255,255,0.92)");
      gHL.addColorStop(1, "rgba(255,255,255,0.00)");
      ctx.fillStyle = gHL;
      ctx.beginPath();
      ctx.arc(hx, hy, hlR, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    };

    eye(W*0.5 - (rx*SEP)/2, cy);
    eye(W*0.5 + (rx*SEP)/2, cy);
  }

  // Convenience: full redraw with new random params
  function redraw() {
    randomizeParams();
    draw();
  }

  // --- CLICK HANDLING + OVERLAY (identical behavior to Mandala) ---
  let clickTimer = null;
  const overlay = document.getElementById('overlay');
  const resRow = document.getElementById('resRow');
  const downloadBtn = document.getElementById('downloadBtn');
  const closeBtn = document.getElementById('closeBtn');

  function openOverlay() {
    overlay.style.display = "flex";
  }
  function closeOverlay() {
    overlay.style.display = "none";
  }

  canvas.addEventListener('click', () => {
    if (clickTimer) return;
    clickTimer = setTimeout(() => {
      clickTimer = null;
      // single click -> new random eyes, same resolution
      redraw();
    }, 260); // small delay to detect double-click
  });

  canvas.addEventListener('dblclick', () => {
    if (clickTimer) {
      clearTimeout(clickTimer);
      clickTimer = null;
    }
    openOverlay();
  });

  overlay.addEventListener('click', e => {
    if (e.target === overlay) closeOverlay();
  });

  // build resolution buttons
  RESOLUTIONS.forEach(res => {
    const btn = document.createElement('button');
    btn.textContent = (res / 1024) + "K";
    if (res === currentRes) {
      btn.style.boxShadow = "0 0 0 1px rgba(255,255,255,0.4)";
    }
    btn.addEventListener('click', () => {
      currentRes = res;
      setupCanvas(currentRes);
      redraw();
      closeOverlay();
      // update button highlighting
      [...resRow.children].forEach(b => b.style.boxShadow = "0 0 0 rgba(0,0,0,0)");
      btn.style.boxShadow = "0 0 0 1px rgba(255,255,255,0.4)";
    });
    resRow.appendChild(btn);
  });

  // download current canvas as PNG
  downloadBtn.addEventListener('click', () => {
    const link = document.createElement('a');
    const stamp = new Date().toISOString().replace(/[:.]/g, "-");
    link.download = `eyez-${(currentRes / 1024)}k-${stamp}.png`;
    link.href = canvas.toDataURL("image/png");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    closeOverlay();
  });

  closeBtn.addEventListener('click', closeOverlay);

  // --- INITIAL SETUP & DRAW ---
  setupCanvas(currentRes);
  redraw();

  // === expose the same tweak helpers as before ===
  window.setScleraStopSpreads = (arr)=>{ SCLERA_STOP_SPREADS = Array.isArray(arr)?arr:[]; draw(); };
  window.setScleraGlobalSpread = (v)=>{ SCLERA_GLOBAL_SPREAD = +v || 1; draw(); };
  window.reseedSclera = ()=>{ reseed(); GRADIENT_STOPS = makeStops(); draw(); };

})();
</script>

</body>
</html>
